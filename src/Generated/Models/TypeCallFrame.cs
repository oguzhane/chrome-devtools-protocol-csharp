// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Core;

namespace Chrome.DevTools.Models
{
    /// <summary> JavaScript call frame. Array of call frames form the call stack. </summary>
    public partial class TypeCallFrame
    {
        /// <summary> Initializes a new instance of TypeCallFrame. </summary>
        /// <param name="callFrameId"> Call frame identifier. This identifier is only valid while the virtual machine is paused. </param>
        /// <param name="functionName"> Name of the JavaScript function called on this call frame. </param>
        /// <param name="location"> Location in the source code. </param>
        /// <param name="url">
        /// JavaScript script name or url.
        /// Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
        /// sent `Debugger.scriptParsed` event.
        /// </param>
        /// <param name="scopeChain"> Scope chain for this call frame. </param>
        /// <param name="this"> `this` object for this call frame. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="callFrameId"/>, <paramref name="functionName"/>, <paramref name="location"/>, <paramref name="url"/>, <paramref name="scopeChain"/> or <paramref name="this"/> is null. </exception>
        public TypeCallFrame(string callFrameId, string functionName, TypeLocation location, string url, IEnumerable<TypeScope> scopeChain, TypeRemoteObject @this)
        {
            Argument.AssertNotNull(callFrameId, nameof(callFrameId));
            Argument.AssertNotNull(functionName, nameof(functionName));
            Argument.AssertNotNull(location, nameof(location));
            Argument.AssertNotNull(url, nameof(url));
            Argument.AssertNotNull(scopeChain, nameof(scopeChain));
            Argument.AssertNotNull(@this, nameof(@this));

            CallFrameId = callFrameId;
            FunctionName = functionName;
            Location = location;
            Url = url;
            ScopeChain = scopeChain.ToList();
            This = @this;
        }

        /// <summary> Initializes a new instance of TypeCallFrame. </summary>
        /// <param name="callFrameId"> Call frame identifier. This identifier is only valid while the virtual machine is paused. </param>
        /// <param name="functionName"> Name of the JavaScript function called on this call frame. </param>
        /// <param name="functionLocation"> Location in the source code. </param>
        /// <param name="location"> Location in the source code. </param>
        /// <param name="url">
        /// JavaScript script name or url.
        /// Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
        /// sent `Debugger.scriptParsed` event.
        /// </param>
        /// <param name="scopeChain"> Scope chain for this call frame. </param>
        /// <param name="this"> `this` object for this call frame. </param>
        /// <param name="returnValue"> The value being returned, if the function is at return point. </param>
        /// <param name="canBeRestarted">
        /// Valid only while the VM is paused and indicates whether this frame
        /// can be restarted or not. Note that a `true` value here does not
        /// guarantee that Debugger#restartFrame with this CallFrameId will be
        /// successful, but it is very likely.
        /// </param>
        internal TypeCallFrame(string callFrameId, string functionName, TypeLocation functionLocation, TypeLocation location, string url, IList<TypeScope> scopeChain, TypeRemoteObject @this, TypeRemoteObject returnValue, bool? canBeRestarted)
        {
            CallFrameId = callFrameId;
            FunctionName = functionName;
            FunctionLocation = functionLocation;
            Location = location;
            Url = url;
            ScopeChain = scopeChain;
            This = @this;
            ReturnValue = returnValue;
            CanBeRestarted = canBeRestarted;
        }

        /// <summary> Call frame identifier. This identifier is only valid while the virtual machine is paused. </summary>
        public string CallFrameId { get; set; }
        /// <summary> Name of the JavaScript function called on this call frame. </summary>
        public string FunctionName { get; set; }
        /// <summary> Location in the source code. </summary>
        public TypeLocation FunctionLocation { get; set; }
        /// <summary> Location in the source code. </summary>
        public TypeLocation Location { get; set; }
        /// <summary>
        /// JavaScript script name or url.
        /// Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
        /// sent `Debugger.scriptParsed` event.
        /// </summary>
        public string Url { get; set; }
        /// <summary> Scope chain for this call frame. </summary>
        public IList<TypeScope> ScopeChain { get; }
        /// <summary> `this` object for this call frame. </summary>
        public TypeRemoteObject This { get; set; }
        /// <summary> The value being returned, if the function is at return point. </summary>
        public TypeRemoteObject ReturnValue { get; set; }
        /// <summary>
        /// Valid only while the VM is paused and indicates whether this frame
        /// can be restarted or not. Note that a `true` value here does not
        /// guarantee that Debugger#restartFrame with this CallFrameId will be
        /// successful, but it is very likely.
        /// </summary>
        public bool? CanBeRestarted { get; set; }
    }
}
